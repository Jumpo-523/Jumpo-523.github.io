{"componentChunkName":"component---src-templates-blog-post-js","path":"/regex/","result":{"data":{"site":{"siteMetadata":{"title":"雑食系のエンジニア志望"}},"markdownRemark":{"id":"cbb7fe1d-c919-5008-aa6e-3c7b556505eb","excerpt":"…","html":"<p>基本的な構造は知っているけど、、結局言語によってばらつきあるみたいだし、一度体系を学んだ方がいいなぁと思いつつ、出てきたら調べるを繰り返してしまいがちな正規表現…</p>\n<p>まぁ本腰入れて勉強するまではないとは思います。せめて遭遇したパターンだけでも覚えてすぐ引けるようにしておきたい。</p>\n<p>そんな思いからこの記事を書いています。そしておそらく書ききることはないので、随時更新を予定しています。</p>\n<h2>まずはここから</h2>\n<ul>\n<li>この動画をみて勉強しました。基礎的な内容はここで把握できます！</li>\n</ul>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/T7Y2kfMm7kk\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<h3><code class=\"language-text\">&quot;[\\w\\-._]+@[\\w\\-._]+\\.[A-Za-z]+&quot;</code></h3>\n<p>???</p>\n<h3><code class=\"language-text\">&quot;^(?=.*?[a-zA-Z])(?=.*?\\d)(?=.*?[!-/:-@[-`{-~])[!-~]{4,100}$&quot;</code></h3>\n<h3>HTML文からテキストデータを抽出する正規表現</h3>\n<ul>\n<li>\n<p>Big Queryの勉強していたら見かけた。</p>\n<ul>\n<li><a href=\"https://ymym3412.hatenablog.com/entry/2020/12/24/001923\">https://ymym3412.hatenablog.com/entry/2020/12/24/001923</a></li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">select\n  regexp_replace(strings, &#39;&lt;(&quot;.*?&quot;|\\&#39;.*?\\&#39;|[^\\&#39;&quot;])*?&gt;&#39;, &#39;&#39;) as clearned\nfrom\n  texts</code></pre></div>\n<p><code class=\"language-text\">&lt;(&quot;.*?&quot;|\\&#39;.*?\\&#39;|[^\\&#39;&quot;])*?&gt;</code></p>\n<ul>\n<li><code class=\"language-text\">A|B</code>はパターンのOR結合を表す。</li>\n<li><code class=\"language-text\">()</code>で囲んで１パターンとして見做す</li>\n<li>\n<p>.*?は最左最短マッチと呼ばれている</p>\n<ul>\n<li>\n<p><code class=\"language-text\">&lt;&lt;&lt;hoge&gt;&gt;&gt;</code>に対して&#x3C;.*?>をパターンマッチさせる際に行われる実際の処理の流れがとてもわかりやすかった。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;         # &lt;までマッチ\n&lt;&lt;        # &lt;&gt;のマッチに失敗、.の数を増やしてリトライ\n&lt;&lt;        # &lt;.までマッチ\n&lt;&lt;&lt;       # &lt;.&gt;のマッチに失敗、.の数を増やしてリトライ\n&lt;&lt;&lt;       # &lt;..までマッチ\n&lt;&lt;&lt;h      # &lt;..&gt;のマッチに失敗、.の数を増やしてリトライ\n&lt;&lt;&lt;h      # &lt;...までマッチ\n&lt;&lt;&lt;ho     # &lt;...&gt;のマッチに失敗、.の数を増やしてリトライ\n&lt;&lt;&lt;ho     # &lt;....までマッチ\n&lt;&lt;&lt;hog    # &lt;....&gt;のマッチに失敗、.の数を増やしてリトライ\n&lt;&lt;&lt;hog    # &lt;.....までマッチ\n&lt;&lt;&lt;hoge   # &lt;.....&gt;のマッチに失敗、.の数を増やしてリトライ\n&lt;&lt;&lt;hoge   # &lt;......までマッチ\n&lt;&lt;&lt;hoge&gt;  # &lt;......&gt;までマッチ</code></pre></div>\n<p>参考文献(<a href=\"https://qiita.com/anqooqie/items/191ad215e93237c77811\">link</a>)</p>\n</li>\n<li>要するに、 <code class=\"language-text\">&lt;</code>を見つけたら、最初の<code class=\"language-text\">&gt;</code>を見つけるまでマッチし続けてくれると言うことになりますね。</li>\n</ul>\n</li>\n</ul>\n<p>また、<a href=\"https://qiita.com/honeydaisuki/items/d2a38cef1b95fd347fa4\">https://qiita.com/honeydaisuki/items/d2a38cef1b95fd347fa4</a> の記事のコメントに詳細が解説されていました。m__m</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">「.」は「任意の1文字」に\n「*」は「直前のパターンの0回以上の最長連続」に\n「*?」は「直前のパターンの0回以上の最短連続」にマッチします。</code></pre></div>\n<h3>つまり…?</h3>\n<p>&#x3C;>で覆われた、文字列, 及び、任意の文字(’：シングルクオーテーションを除く)に対してマッチして、空文字と置き換えますよ。と言うこと。</p>","frontmatter":{"title":"regexに慣れよう。（加筆予定）","date":"December 12, 2020","description":null}},"previous":{"fields":{"slug":"/iot/iot/"},"frontmatter":{"title":"IoT ハッカソンに出てきました。"}},"next":{"fields":{"slug":"/iot/idea/"},"frontmatter":{"title":"IoT、こういうこともしたい。"}}},"pageContext":{"id":"cbb7fe1d-c919-5008-aa6e-3c7b556505eb","previousPostId":"dce34e0e-a6a5-5c85-ae7d-fcd42ef71b63","nextPostId":"11a5fdfb-de6d-5ee3-8d2f-9d22b58de606"}},"staticQueryHashes":["2841359383","3184796268"]}